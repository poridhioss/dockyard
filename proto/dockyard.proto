syntax = "proto3";

package dockyard;

service DockyardService {
    rpc LaunchContainer(LaunchRequest) returns (LaunchResponse);
    rpc StopContainer(StopRequest) returns (StopResponse);
    rpc ExecContainer(stream ExecRequest) returns (stream ExecResponse);
    rpc GetLogs(LogsRequest) returns (stream LogsResponse);
}

message LaunchRequest {
    string image = 1;
    string name = 2;
    string config_file = 3;
}

message LaunchResponse {
    bool success = 1;
    string container_id = 2;
    string message = 3;
}

message StopRequest {
    string container_identifier = 1; // name or ID
    bool force = 2;                  // force stop (kill vs graceful)
    int32 timeout = 3;              // timeout in seconds
}

message StopResponse {
    bool success = 1;
    string container_id = 2;
    string message = 3;
}

message ExecRequest {
    oneof request_type {
        ExecStart start = 1;
        ExecInput input = 2;
    }
}

message ExecStart {
    string container_identifier = 1; // name or ID
    repeated string command = 2;     // command and arguments
    bool interactive = 3;            // allocate TTY for interactive session
    string user = 4;                 // user to run as (optional)
    string working_dir = 5;          // working directory (optional)
    map<string, string> environment = 6; // environment variables
}

message ExecInput {
    bytes data = 1;                  // stdin data
}

message ExecResponse {
    oneof response_type {
        ExecStatus status = 1;
        ExecOutput output = 2;
    }
}

message ExecStatus {
    bool success = 1;
    string exec_id = 2;              // execution ID
    string message = 3;
    int32 exit_code = 4;             // command exit code (when finished)
    bool finished = 5;               // true when command execution is complete
}

message ExecOutput {
    bytes data = 1;                  // stdout/stderr data
    string stream_type = 2;          // "stdout" or "stderr"
}

message LogsRequest {
    string container_identifier = 1; // name or ID
    bool follow = 2;                 // follow log output (like tail -f)
    int32 tail = 3;                  // number of lines from end (0 = all)
    string since = 4;                // relative time (e.g., "1h", "30m", "10s")
    bool timestamps = 5;             // show timestamps
    bool stdout = 6;                 // include stdout (default true)
    bool stderr = 7;                 // include stderr (default true)
}

message LogsResponse {
    oneof response_type {
        LogsStatus status = 1;
        LogEntry log = 2;
    }
}

message LogsStatus {
    bool success = 1;
    string message = 2;
    bool finished = 3;               // true when all logs have been sent (for non-follow mode)
}

message LogEntry {
    bytes data = 1;                  // log line data
    string stream_type = 2;          // "stdout" or "stderr"
    string timestamp = 3;            // ISO 8601 timestamp (if timestamps enabled)
}