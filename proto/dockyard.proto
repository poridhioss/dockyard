syntax = "proto3";

package dockyard;

service DockyardService {
    rpc LaunchContainer(LaunchRequest) returns (LaunchResponse);
    rpc StopContainer(StopRequest) returns (StopResponse);
    rpc ExecContainer(stream ExecRequest) returns (stream ExecResponse);
    rpc GetLogs(LogsRequest) returns (stream LogsResponse);
    rpc ListContainers(ListContainersRequest) returns (ListContainersResponse);
    rpc InspectContainer(InspectContainerRequest) returns (InspectContainerResponse);
    rpc RemoveContainer(RemoveContainerRequest) returns (RemoveContainerResponse);
    rpc GetStats(StatsRequest) returns (stream StatsResponse);
}

message LaunchRequest {
    string image = 1;
    string name = 2;
    string config_file = 3;
}

message LaunchResponse {
    bool success = 1;
    string container_id = 2;
    string message = 3;
}

message StopRequest {
    string container_identifier = 1; // name or ID
    bool force = 2;                  // force stop (kill vs graceful)
    int32 timeout = 3;              // timeout in seconds
}

message StopResponse {
    bool success = 1;
    string container_id = 2;
    string message = 3;
}

message ExecRequest {
    oneof request_type {
        ExecStart start = 1;
        ExecInput input = 2;
    }
}

message ExecStart {
    string container_identifier = 1; // name or ID
    repeated string command = 2;     // command and arguments
    bool interactive = 3;            // allocate TTY for interactive session
    string user = 4;                 // user to run as (optional)
    string working_dir = 5;          // working directory (optional)
    map<string, string> environment = 6; // environment variables
}

message ExecInput {
    bytes data = 1;                  // stdin data
}

message ExecResponse {
    oneof response_type {
        ExecStatus status = 1;
        ExecOutput output = 2;
    }
}

message ExecStatus {
    bool success = 1;
    string exec_id = 2;              // execution ID
    string message = 3;
    int32 exit_code = 4;             // command exit code (when finished)
    bool finished = 5;               // true when command execution is complete
}

message ExecOutput {
    bytes data = 1;                  // stdout/stderr data
    string stream_type = 2;          // "stdout" or "stderr"
}

message LogsRequest {
    string container_identifier = 1; // name or ID
    bool follow = 2;                 // follow log output (like tail -f)
    int32 tail = 3;                  // number of lines from end (0 = all)
    string since = 4;                // relative time (e.g., "1h", "30m", "10s")
    bool timestamps = 5;             // show timestamps
    bool stdout = 6;                 // include stdout (default true)
    bool stderr = 7;                 // include stderr (default true)
}

message LogsResponse {
    oneof response_type {
        LogsStatus status = 1;
        LogEntry log = 2;
    }
}

message LogsStatus {
    bool success = 1;
    string message = 2;
    bool finished = 3;               // true when all logs have been sent (for non-follow mode)
}

message LogEntry {
    bytes data = 1;                  // log line data
    string stream_type = 2;          // "stdout" or "stderr"
    string timestamp = 3;            // ISO 8601 timestamp (if timestamps enabled)
}

message ListContainersRequest {
    bool all = 1;                    // Show all containers (including stopped)
}

message ContainerInfo {
    string id = 1;                   // Container ID (short)
    string image = 2;                // Image name
    string command = 3;              // Command being run
    string created = 4;              // Creation time
    string status = 5;               // Current status
    string ports = 6;                // Port mappings
    string names = 7;                // Container name
}

message ListContainersResponse {
    bool success = 1;
    repeated ContainerInfo containers = 2;
    string message = 3;
}

message InspectContainerRequest {
    string container_identifier = 1; // name or ID
}

message InspectContainerResponse {
    bool success = 1;
    string json_data = 2;            // Full JSON inspection data
    string message = 3;
}

message RemoveContainerRequest {
    string container_identifier = 1; // name or ID
    bool force = 2;                  // Force removal of running container
}

message RemoveContainerResponse {
    bool success = 1;
    string container_id = 2;
    string message = 3;
}

message StatsRequest {
    repeated string container_identifiers = 1; // Empty = all running containers
    bool stream = 2;                 // Continuous streaming vs one-time
}

message ContainerStats {
    string container_id = 1;
    string name = 2;
    double cpu_percentage = 3;
    uint64 memory_usage = 4;         // Memory usage in bytes
    uint64 memory_limit = 5;         // Memory limit in bytes
    double memory_percentage = 6;
    uint64 network_rx = 7;           // Network received bytes
    uint64 network_tx = 8;           // Network transmitted bytes
    uint64 block_read = 9;           // Block I/O read bytes
    uint64 block_write = 10;         // Block I/O write bytes
    uint32 pids = 11;                // Number of PIDs
}

message StatsResponse {
    repeated ContainerStats stats = 1;
    string timestamp = 2;            // When stats were collected
    string message = 3;              // Error message if any
    bool success = 4;
}